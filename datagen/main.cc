/* COPYRIGHT (C) 2018 Julian Offenhäuser
*
* Convert .rocket to binary and generate
* a C++ header
*/

#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <bitset>
#include <sstream>
#include <algorithm>

#include "tinyxml2.h"


using namespace tinyxml2;



typedef struct Key
{
	float value;
	unsigned int time;
	unsigned char inter;
	unsigned char track;
};

typedef struct Track
{
	std::string name;
	int muteKeyCount = 0;
	std::vector<Key> keys;
};



static std::string bin_name;
namespace HEADER
{
	// Key count
	static int NUM_EVENTS = 0;
	// Track count
	static int NUM_TRACKS = 0;
	// Number of used rows
	static int NUM_ROWS = 0;
	// Embedded resource
	std::string dat;
}

namespace DATA
{
	static std::vector<Track> tracks;
};


void Error(std::string err)
{
	std::cerr << err << "\n";
	exit(1);
}

std::string GenerateHeader()
{
	using namespace HEADER;

	std::string str;

	// Disclaimer
	str += "/* Generated by " + bin_name + " */\n\n\n";
	// Pragma guard
	str += "#pragma once\n\n\n";
	// Constants
	str += "#define NUM_TRACKS " + std::to_string(NUM_TRACKS) + "\n";
	str += "#define NUM_ROWS " + std::to_string(NUM_ROWS) + "\n";
	str += "#define NUM_EVENTS " + std::to_string(NUM_EVENTS) + "\n";

	str += "\n";

	str += "#define INTER_LINEAR " + std::to_string(1) + "\n";
	str += "#define INTER_SMOOTH " + std::to_string(2) + "\n";
	str += "#define INTER_RAMP " + std::to_string(3) + "\n";

	str += "\n";

	bool i1, i2, i3 = false;
	for (const auto& t : DATA::tracks)
	{
		for (const auto& k : t.keys)
		{
			if (k.inter == 1) i1 = true;
			else if (k.inter == 2) i2 = true;
			else if (k.inter == 3) i3 = true;
		}
	}

	if (i1) str += "#define USED_INTER_LINEAR\n";
	if (i2) str += "#define USED_INTER_SMOOTH\n";
	if (i3) str += "#define USED_INTER_RAMP\n";
	if (!i1 && !i2 && !i3) str += "#define NO_INTER\n";

	/*str += "\n";
	for (int i = 0; i < DATA::tracks.size(); i++)
	{
	std::string s = "TRACK_" + DATA::tracks[i].name;
	std::transform(s.begin(), s.end(), s.begin(), ::toupper);
	str += "#define " + s + " " + std::to_string(i) + "\n";
	}
	str += "\n";*/

	// Key definition
	str += "\ntypedef struct\n";
	str += "{\n";
	str += "	unsigned int time;\n";
	str += "	float value;\n";
	str += "	unsigned char inter;\n";
	str += "	unsigned char track;\n";
	str += "}SyncKey;\n\n\n";
	// Namespace start
	str += "namespace SYNC_DATA\n{\n";
	// Resource
	str += "	#pragma bss_seg(" + std::string(1, '"') + ".sync" + std::string(1, '"') + ")\n";
	str += "	SyncKey sync_data[NUM_EVENTS] = {\n";

	int tr = 0;
	for (const auto& t : DATA::tracks) {
		for (const auto& k : t.keys) {
			std::ostringstream ss;
			ss << k.value;
			std::string s(ss.str());
			str += "		{ " + std::to_string(k.time) + ", " + s + ", " + std::to_string(k.inter) + ", " + std::to_string(tr) + " },\n";
		}

		tr++;
	}

	str += "	};\n";

	// Namespace end
	str += "};\n";

	return str;
}

std::string GenerateData()
{
	using namespace DATA;

	std::string dat;

	for (const auto& t : tracks) {
		for (const auto& k : t.keys) {
			// Offset (2 bytes)
			dat.append((const char*)&k.time, 2);
			// Value (4 bytes)
			dat.append((const char*)&k.value, 4);
			// Interpolation (1 byte)
			dat.append((const char*)&k.inter, 1);
		}
	}

	return dat;
}

int main(int argc, char** argv)
{
	using namespace DATA;

	if (argc < 4)
		Error("Too few arguments");

	bin_name = argv[0];

	std::string in(argv[1]);
	std::string out(argv[2]);
	std::string header(argv[3]);

	XMLDocument doc;
	if (doc.LoadFile(in.c_str()) != XML_SUCCESS) Error("Unable to load file: " + in);

	XMLNode* pXml = doc.FirstChild();
	XMLElement* pRoot = doc.FirstChildElement();

	if (!pRoot) Error("No root element found");

	XMLElement* pTracks = pRoot->FirstChildElement();
	int rows = pTracks->IntAttribute("rows");
	int startRow = pTracks->IntAttribute("startRow");
	int endRow = pTracks->IntAttribute("endRow");
	int rowsPerBeat = pTracks->IntAttribute("rowsPerBeat");
	int beatsPerMin = pTracks->IntAttribute("beatsPerMin");

	// Get tracks
	for (tinyxml2::XMLElement* track = pTracks->FirstChildElement(); track != NULL; track = track->NextSiblingElement()) {
		std::string val = track->Value();
		if (val == "track") {
			Track t;

			bool folded = track->IntAttribute("folded");
			int muteKeyCount = track->IntAttribute("muteKeyCount");
			t.name = track->Attribute("name");

			// Get keys
			for (tinyxml2::XMLElement* key = track->FirstChildElement(); key != NULL; key = key->NextSiblingElement()) {
				Key k;

				k.time = key->IntAttribute("row");
				k.value = key->FloatAttribute("value");
				k.inter = key->IntAttribute("interpolation");

				/* If value == 0, it will be skipped, we don't
				want that in this case
				Todo: get rid of this ugly workaround */
				if (k.value == 0)
					k.value = 0.000001;

				t.keys.push_back(k);
			}

			HEADER::NUM_EVENTS += t.keys.size();

			tracks.push_back(t);
		}
	}

	// Generate data
	std::string d = GenerateData();

	// Write data
	std::ofstream(out, std::ofstream::out) << d;

	/* Set header data */

	// Num tracks
	HEADER::NUM_TRACKS = tracks.size();
	// Calculate used rows
	HEADER::NUM_ROWS = []() -> int {
		int c = 0;
		for (const auto& t : tracks)
		{
			for (const auto& k : t.keys)
			{
				if (k.time > c)
					c = k.time;
			}
		}
		return c;
	}() + 1;
	// Embedded resource
	HEADER::dat = d;

	// Write C++ header file
	std::ofstream(header, std::ofstream::out) << GenerateHeader();

	std::cout << "\nSuccessfully written sync data to '" << out << "' and C++ header to '" << header << "'\n\n";

	return 0;
}