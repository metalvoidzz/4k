/* COPYRIGHT (C) 2018 Julian Offenhäuser
 *
 * Convert .rocket to binary and generate
 * a C++ header
 */

#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <bitset>
#include <sstream>

#include "tinyxml2.h"


using namespace tinyxml2;



typedef struct Key
{
	float value;
	unsigned short time;
	unsigned char inter;
	unsigned char index = 0xFF;
};

typedef struct Track
{
	std::string name;
	int muteKeyCount = 0;
	std::vector<Key> keys;
};



static std::string bin_name;
namespace HEADER
{
	// Key count
	static int NUM_EVENTS = 0;
	// Track count
	static int NUM_TRACKS = 0;
	// Number of used rows
	static int NUM_ROWS = 0;
	// Embedded resource
	std::string dat;
}

namespace DATA
{
	static std::vector<Track> tracks;
};


void Error(std::string err)
{
	std::cerr << err << "\n";
	exit(1);
}

std::string GenerateHeader()
{
	using namespace HEADER;

	std::string str;

	// Disclaimer
	str += "/* Generated by " + bin_name + " */\n\n\n";
	// Pragma guard
	str += "#pragma once\n\n";
	// Constants
	str += "#define NUM_TRACKS " + std::to_string(NUM_TRACKS) + "\n";
	str += "#define NUM_ROWS " + std::to_string(NUM_ROWS) + "\n";
	str += "#define NUM_EVENTS " + std::to_string(NUM_EVENTS) + "\n";
	// Key definition
	str += "\nstruct SyncKey\n";
	str += "{\n";
	str += "	unsigned short time;\n";
	str += "	float value;\n";
	str += "	unsigned char index;\n";
	str += "	unsigned char inter;\n";
	str += "};\n\n";
	// Namespace start
	str += "namespace SYNC_DATA\n{\n";
	// Resource
	str += "	#pragma bss_seg(" + std::string(1, '"') + ".sync" + std::string(1, '"') + ")\n";
	str += "	SyncKey sync_data[NUM_EVENTS] = {\n";
	
	for (const auto& t: DATA::tracks)
	{
		for (const auto& k: t.keys)
		{
			std::ostringstream ss;
			ss << k.value;
			std::string s(ss.str());
			str += "		{ " + std::to_string(k.time) + ", " + s + ", " + std::to_string(k.index) + ", " + std::to_string(k.inter) + " },\n";
		}
	}

	str += "	};\n";

	// Namespace end
	str += "};\n";

	return str;
}

std::string GenerateData()
{
	using namespace DATA;

	std::string dat;

	for (const auto& t: tracks)
	{
		for (const auto& k : t.keys)
		{
			// Offset (2 bytes)
			dat.append((const char*)&k.time, 2);
			// Value (4 bytes)
			dat.append((const char*)&k.value, 4);
			// Index (1 byte)
			dat.append((const char*)&k.index, 1);
			// Interpolation (1 byte)
			dat.append((const char*)&k.inter, 1);
		}
	}

	return dat;
}

int main(int argc, char** argv)
{
	using namespace DATA;

	if (argc < 4)
		Error("Too few arguments");

	bin_name = argv[0];

	std::string in(argv[1]);
	std::string out(argv[2]);
	std::string header(argv[3]);

	XMLDocument doc;
	if(doc.LoadFile(in.c_str()) != XML_SUCCESS) Error("Unable to load file: " + in);

	XMLNode* pXml = doc.FirstChild();
	XMLElement* pRoot = doc.FirstChildElement();

	if (!pRoot) Error("No root element found");

	XMLElement* pTracks = pRoot->FirstChildElement();
	int rows = pTracks->IntAttribute("rows");
	int startRow = pTracks->IntAttribute("startRow");
	int endRow = pTracks->IntAttribute("endRow");
	int rowsPerBeat = pTracks->IntAttribute("rowsPerBeat");
	int beatsPerMin = pTracks->IntAttribute("beatsPerMin");

	// Get tracks
	for (tinyxml2::XMLElement* track = pTracks->FirstChildElement(); track != NULL; track = track->NextSiblingElement())
	{
		std::string val = track->Value();
		if (val == "track")
		{
			Track t;

			bool folded = track->IntAttribute("folded");
			int muteKeyCount = track->IntAttribute("muteKeyCount");
			t.name = track->Attribute("name");

			// Get keys
			for (tinyxml2::XMLElement* key = track->FirstChildElement(); key != NULL; key = key->NextSiblingElement())
			{
				Key k;

				k.time = key->IntAttribute("row");
				k.value = key->FloatAttribute("value");
				k.inter = key->IntAttribute("interpolation");

				t.keys.push_back(k);
			}

			HEADER::NUM_EVENTS += t.keys.size();

			tracks.push_back(t);
		}
	}

	// Generate data
	std::string d = GenerateData();

	// Write data
	std::ofstream(out, std::ofstream::out) << d;

	/* Set header data */

	// Num tracks
	HEADER::NUM_TRACKS = tracks.size();
	// Calculate used rows
	HEADER::NUM_ROWS = []() -> int {
		int c = 0;
		for (const auto& t : tracks)
			for (const auto& r : t.keys)
				if (r.time > 0)
					c = r.time;
		return c;
	}();
	// Embedded resource
	HEADER::dat = d;

	// Write C++ header file
	std::ofstream(header, std::ofstream::out) << GenerateHeader();

	std::cout << "\nSuccessfully written sync data to '" << out << "' and C++ header to '" << header << "'\n\n";

	return 0;
}