/* File generated with Shader Minifier 1.1.5
 * http://www.ctrl-alt-test.fr
 */
#ifndef AUTO_PSHADER_H_
# define AUTO_PSHADER_H_
# define VAR_U_ALPHA "f"
# define VAR_U_TIME "v"
# define VAR_U_X "y"
# define VAR_U_Y "x"
# define VAR_U_Z "z"

const char *pshader_glsl =
 "#version 120\n"
 "uniform float v,f,y,x,z;\n"
 "#define WIDTH 800\n"
 "#define HEIGHT 600\n"
 "#define PI 3.141592\n"
 "#define MAX_ITER 255\n"
 "#define MAX_DIST 100.0\n"
 "#define EPSILON 0.0001\n"
 "#define OMEGA 1.2\n"
 "#define WH vec2(WIDTH,HEIGHT)\n"
 "mat3 n(float v)"
 "{"
   "float y=cos(v),f=sin(v);"
   "return mat3(vec3(1,0,0),vec3(0,y,-f),vec3(0,f,y));"
 "}"
 "mat3 m(float v)"
 "{"
   "float f=cos(v),y=sin(v);"
   "return mat3(vec3(f,0,y),vec3(0,1,0),vec3(-y,0,f));"
 "}"
 "mat3 s(float v)"
 "{"
   "float f=cos(v),y=sin(v);"
   "return mat3(vec3(f,-y,0),vec3(y,f,0),vec3(0,0,1));"
 "}"
 "float m(vec3 v,float m)"
 "{"
   "return length(v)-m;"
 "}"
 "float e(vec3 v)"
 "{"
   "return max(max(v.x,v.y),v.z);"
 "}"
 "float e(vec3 v,vec3 m)"
 "{"
   "return e(abs(v)-m);"
 "}"
 "float n(vec3 v,vec2 m)"
 "{"
   "vec2 f=vec2(length(v.xz)-m.x,v.y);"
   "return length(f)-m.y;"
 "}"
 "float s(float v,float f)"
 "{"
   "return min(v,f);"
 "}"
 "float t(float m,float v)"
 "{"
   "return max(-m,v);"
 "}"
 "float h(float v,float f)"
 "{"
   "return max(v,f);"
 "}"
 "float e(float v,float f,float m)"
 "{"
   "float y=min(v,f);"
   "if(v<m&&f<m)"
     "return min(y,m-sqrt((m-v)*(m-v)+(m-f)*(m-f)));"
   "else"
     " return y;"
 "}\n"
 "#define Repeat(p,c)mod(p,c)-0.5*c\n"
 "float h(vec3 f)"
 "{"
   "float y=n(f,vec2(cos(sin(v))*2,.1));"
   "return min(y,m(f,.3));"
 "}"
 "float c(vec3 v,vec3 m)"
 "{"
   "float f=0.;"
   "for(int r=0;r<MAX_ITER;r++)"
     "{"
       "float y=h(v+f*m);"
       "if(y<EPSILON)"
         "return f;"
       "f+=y;"
       "if(f>=MAX_DIST)"
         "break;"
     "}"
   "return MAX_DIST;"
 "}"
 "vec3 M(float v,vec2 m)"
 "{"
   "vec2 f=gl_FragCoord.xy-m/2.;"
   "float y=m.y/tan(radians(v)/2.);"
   "return normalize(vec3(f,-y));"
 "}"
 "vec3 M(vec3 v)"
 "{"
   "return normalize(vec3(h(vec3(v.x+EPSILON,v.y,v.z))-h(vec3(v.x-EPSILON,v.y,v.z)),h(vec3(v.x,v.y+EPSILON,v.z))-h(vec3(v.x,v.y-EPSILON,v.z)),h(vec3(v.x,v.y,v.z+EPSILON))-h(vec3(v.x,v.y,v.z-EPSILON))));"
 "}"
 "mat4 M(vec3 v,vec3 f,vec3 m)"
 "{"
   "vec3 y=normalize(f-v),x=normalize(cross(y,m)),r=cross(x,y);"
   "return mat4(vec4(x,0.),vec4(r,0.),vec4(-y,0.),vec4(0.,0.,0.,1));"
 "}"
 "vec3 c(vec3 v)"
 "{"
   "return v.y=max(v.y,0.),vec3(pow(1.-v.y,2.),1.-v.y,.6+(1.-v.y)*.4);"
 "}"
 "vec3 M(vec3 v,vec3 f,float y,vec3 m,vec3 x,vec3 r,vec3 z)"
 "{"
   "vec3 c=M(m),p=normalize(r-m),N=normalize(x-m),H=normalize(reflect(-p,c));"
   "float s=dot(p,c),W=dot(H,N);"
   "if(s<0.)"
     "return vec3(0.,0.,0.);"
   "if(W<0.)"
     "return z*(v*s);"
   "return z*(v*s+f*pow(W,y));"
 "}"
 "vec3 M(vec3 y,vec3 f,vec3 m,float x,vec3 c,vec3 z)"
 "{"
   "const vec3 n=.2*vec3(1.,1.,1.);"
   "vec3 r=n*y,N=vec3(4.*sin(v)*3,2.,4.*cos(v))*3,H=vec3(.4,.4,.4);"
   "r+=M(f,m,x,c,z,N,H);"
   "vec3 W=vec3(2.*sin(.37*v)*3,2.*cos(.37*v)*3,2.),s=vec3(.4,.4,.4);"
   "r+=M(f,m,x,c,z,W,s);"
   "return r;"
 "}"
 "void main()"
 "{"
   "vec2 v=gl_FragCoord.xy/WH;"
   "v=v*2.-1.;"
   "v.x*=WIDTH/HEIGHT;"
   "vec3 m=M(45.,WH),N=vec3(8.,5.,1.);"
   "mat4 r=M(N,vec3(y,x,z),vec3(0.,1.,0.));"
   "vec3 s=(r*vec4(m,0.)).xyz;"
   "float W=c(N,s);"
   "vec3 i=normalize(vec3(v.xy,-2.));"
   "i.z+=length(v)*.15;"
   "if(W>MAX_DIST-EPSILON)"
     "{"
       "gl_FragColor=vec4(c(i)-f,0.);"
       "return;"
     "}"
   "vec3 H=N+W*s,p=vec3(.2,.2,.2),n=vec3(.7,.2,.2),e=vec3(1.,1.,1.);"
   "float l=10.;"
   "vec3 t=M(p,n,e,l,H,N);"
   "gl_FragColor=vec4(t-f,1.);"
 "}";

#endif // AUTO_PSHADER_H_
